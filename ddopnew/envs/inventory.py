# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/21_envs_inventory/10_single_period_envs.ipynb.

# %% auto 0
__all__ = ['BaseInventoryEnv', 'NewsvendorEnv', 'NewsvendorVariableSLEnv']

# %% ../../nbs/21_envs_inventory/10_single_period_envs.ipynb 3
from abc import ABC, abstractmethod
from typing import Union


from .base import BaseEnvironment
from ..utils import Parameter, set_env_parameter, MDPInfo
from ..dataloaders.base import BaseDataLoader
from ..loss_functions import pinball_loss

import gymnasium as gym

import numpy as np

# %% ../../nbs/21_envs_inventory/10_single_period_envs.ipynb 4
class BaseInventoryEnv(BaseEnvironment):
    def __init__(self, mdp_info: MDPInfo) -> None:
        """
        Constructor.

        Args:
            mdp_info (MDPInfo): the information of the environment;
            kwargs (dict): the keyword arguments to set the environment.

        # TODO check if this class is necessary
            
        """
        super().__init__(mdp_info)
    
    def set_observation_space(self, shape: tuple, low: Union[np.ndarray, float] = -np.inf, high: Union[np.ndarray, float] = np.inf) -> None:
        '''
        Set the observation space of the environment.
        This is a standard function for simple observation spaces. For more complex observation spaces,
        this function should be overwritten. Note that it is assumped that the first dimension
        is the n_samples that is not relevant for the observation space.

        '''
        if shape is not None:
            if not isinstance(shape, tuple):
                raise ValueError("Shape must be a tuple.")
            
            shape = shape[1:] # assumed that the first dimension is the number of samples

            self.observation_space = gym.spaces.Box(low=low, high=high, shape=shape, dtype=np.float32)
        else:
            self.observation_space = None

    def set_action_space(self, shape: tuple, low: Union[np.ndarray, float] = 0, high: Union[np.ndarray, float] = np.inf) -> None:
        '''
        Set the action space of the environment.
        This is a standard function for simple action spaces. For more complex action spaces,
        this function should be overwritten. Note that it is assumped that the first dimension
        is the n_samples that is not relevant for the action space.

        '''
        if not isinstance(shape, tuple):
            raise ValueError("Shape must be a tuple.")
        
        shape = shape[1:] # assumed that the first dimension is the number of samples

        self.action_space = gym.spaces.Box(low=low, high=high, shape=shape, dtype=np.float32)
    
    def get_observation(self):
        """
        Return the current observation. This function is for the simple case where the observation
        is only an x,y pair. For more complex observations, this function should be overwritten.

        """
        X_item, Y_item = self.dataloader[self.index]
        return X_item, Y_item

# %% ../../nbs/21_envs_inventory/10_single_period_envs.ipynb 5
class NewsvendorEnv(BaseInventoryEnv, ABC):
    """
    
    """
    def __init__(self,
        underage_cost: Union[np.ndarray, Parameter] = np.array([1]),
        overage_cost: Union[np.ndarray, Parameter] = np.array([1]),
        q_bound_low: Union[np.ndarray, Parameter] = np.array([0]),
        q_bound_high: Union[np.ndarray, Parameter] = np.array([np.inf]),
        dataloader: BaseDataLoader = None,
        gamma: float = 1,
        horizon: int = 100,
    ) -> None:
    
        self.dataloader = dataloader
        self.num_SKUs = dataloader.num_SKUs

        self.underage_cost = set_env_parameter(underage_cost, self.num_SKUs)
        self.overage_cost = set_env_parameter(overage_cost, self.num_SKUs)

        q_bound_low = set_env_parameter(q_bound_low, self.num_SKUs)
        q_bound_high = set_env_parameter(q_bound_high, self.num_SKUs)

        self.set_observation_space(dataloader.X_shape)
        self.set_action_space(dataloader.Y_shape)

        super().__init__(mdp_info=MDPInfo(self.observation_space, self.action_space, gamma=gamma, horizon=horizon))
        
    def step(self, action):
        
        cost_per_SKU = -pinball_loss(self.demand, action, self.underage_cost, self.overage_cost)
        reward = -np.sum(cost_per_SKU)

        terminated = False # in this problem there is no termination condition
        
        info = dict(
            demand=self.demand.copy(),
            action=action.copy(),
            cost_per_SKU=cost_per_SKU.copy()
        )

        observation, self.demand = self.get_observation()
        
        truncated = self.handle_index()

        return observation, reward, terminated, truncated, info

    def reset(self,
        start_index: Union[int,str] = 0):
 
        if start_index=="random":
            self.index = np.random.randint(0, len(self.dataloader))
        elif isinstance(start_index, int):
            self.index=start_index

        observation, self.demand = self.get_observation()

        return observation

# %% ../../nbs/21_envs_inventory/10_single_period_envs.ipynb 7
class NewsvendorVariableSLEnv(NewsvendorEnv, ABC):
    """

    """
    def __init__(self,
        underage_cost: Union[np.ndarray, Parameter] = np.array([1]),
        overage_cost: Union[np.ndarray, Parameter] = np.array([1]),
        q_bound_low: Union[np.ndarray, Parameter] = np.array([0]),
        q_bound_high: Union[np.ndarray, Parameter] = np.array([np.inf]),
        dataloader: BaseDataLoader = None,
        gamma: float = 1,
        horizon: int = 100,

        low_sl: np.ndarray = np.array([0.1]),
        high_sl: np.ndarray = np.array([0.9]),

    ) -> None:
    
        super().__init__( 
            underage_cost=underage_cost,
            overage_cost=overage_cost,
            q_bound_low=q_bound_low,
            q_bound_high=q_bound_high,
            dataloader=dataloader,
            gamma=gamma,
            horizon=horizon,
        )

        self.low_sl = set_env_parameter(low_sl, self.num_SKUs)
        self.high_sl = set_env_parameter(high_sl, self.num_SKUs)
    
    def set_observation_space(self, shape: tuple, low: Union[np.ndarray, float] = -np.inf, high: Union[np.ndarray, float] = np.inf) -> None:
        '''
        Set the observation space of the environment.
        '''
        if shape is not None:
            if not isinstance(shape, tuple):
                raise ValueError("Shape must be a tuple.")
            
            shape = shape[1:]
        
            self.observation_space = gym.spaces.Dict({
                'X': gym.spaces.Box(low=low, high=high, shape=shape, dtype=np.float32),
                'sl': gym.spaces.Box(low=0, high=1, shape=(self.num_SKUs,), dtype=np.float32)
            })
        else:
            self.observation_space = gym.spaces.Dict({
                'sl': gym.spaces.Box(low=0, high=1, shape=(self.num_SKUs,), dtype=np.float32)
            })

    def get_observation(self):
        """
        Return the current observation.
        """
        
        X_item, Y_item = self.dataloader[self.index]

        underage_cost, overage_cost, sl = self.draw_service_level()

        self.underage_cost.set_value(underage_cost, (self.num_SKUs,))
        self.overage_cost.set_value(overage_cost, (self.num_SKUs,))

        if X_item is not None:
            obs = {'X': X_item, 'sl': sl}
        else:
            obs = {'sl': sl}

        return obs, Y_item
    
    def draw_service_level(self):
        
        sl = np.random.uniform(self.low_sl, self.high_sl, self.num_SKUs)

        overage_cost = np.ones_like(sl)
        underage_cost = np.ones_like(sl)

        # # Calculate underage_cost where sl >= 0.5
        underage_cost = np.where(sl < 0.5, sl / (1 - sl), underage_cost)
        
        # Calculate overage_cost where sl < 0.5
        overage_cost = np.where(sl >= 0.5, 1 / sl -1, overage_cost)
        
        return underage_cost, overage_cost, sl
