# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/21_envs_inventory/10_single_period_envs.ipynb.

# %% auto 0
__all__ = ['BaseInventoryEnv', 'NewsvendorEnv']

# %% ../../nbs/21_envs_inventory/10_single_period_envs.ipynb 3
from abc import ABC, abstractmethod
from typing import Union

from .base import BaseEnvironment
from ..utils import Parameter, MDPInfo
from ..dataloaders.base import BaseDataLoader
from ..loss_functions import pinball_loss

import gymnasium as gym

import numpy as np
import time

# %% ../../nbs/21_envs_inventory/10_single_period_envs.ipynb 4
class BaseInventoryEnv(BaseEnvironment):
    def __init__(self, mdp_info: MDPInfo) -> None:
        """
        Constructor.
        
        Args:
            mdp_info (MDPInfo): the information of the environment;
            kwargs (dict): the keyword arguments to set the environment.
            
        """
        super().__init__(mdp_info)
    
    def set_observation_space(self,
                            shape: tuple,
                            low: Union[np.ndarray, float] = -np.inf,
                            high: Union[np.ndarray, float] = np.inf,
                            samples_dim_included = True) -> None:
        '''
        Set the observation space of the environment.
        This is a standard function for simple observation spaces. For more complex observation spaces,
        this function should be overwritten. Note that it is assumped that the first dimension
        is the n_samples that is not relevant for the observation space.

        '''

        # To handle cases when no external information is available (e.g., parametric NV)
        
        if shape is None:
            self.observation_space = None

        else:
            if not isinstance(shape, tuple):
                raise ValueError("Shape must be a tuple.")
            
            if samples_dim_included:
                shape = shape[1:] # assumed that the first dimension is the number of samples

            self.observation_space = gym.spaces.Box(low=low, high=high, shape=shape, dtype=np.float32)

    def set_action_space(self,
                        shape: tuple,
                        low: Union[np.ndarray, float] = 0,
                        high: Union[np.ndarray, float] = np.inf,
                        samples_dim_included = True) -> None:
        '''
        Set the action space of the environment.
        This is a standard function for simple action spaces. For more complex action spaces,
        this function should be overwritten. Note that it is assumped that the first dimension
        is the n_samples that is not relevant for the action space.

        '''

        if not isinstance(shape, tuple):
            raise ValueError("Shape must be a tuple.")
        
        if samples_dim_included:
            shape = shape[1:] # assumed that the first dimension is the number of samples

        self.action_space = gym.spaces.Box(low=low, high=high, shape=shape, dtype=np.float32)
    
    def get_observation(self):
        
        """
        Return the current observation. This function is for the simple case where the observation
        is only an x,y pair. For more complex observations, this function should be overwritten.

        """
        
        X_item, Y_item = self.dataloader[self.index]
        return X_item, Y_item

# %% ../../nbs/21_envs_inventory/10_single_period_envs.ipynb 5
class NewsvendorEnv(BaseInventoryEnv, ABC):
    
    """
    XXX
    """

    def __init__(self,
        underage_cost: Union[np.ndarray, Parameter] = np.array([1]),
        overage_cost: Union[np.ndarray, Parameter] = np.array([1]),
        q_bound_low: Union[np.ndarray, Parameter] = np.array([0]),
        q_bound_high: Union[np.ndarray, Parameter] = np.array([np.inf]),
        dataloader: BaseDataLoader = None,
        num_SKUs: Union[int] = None, # if None it will be inferred from the DataLoader
        gamma: float = 1,
        horizon_train: Union[str, int] = 100, # if "use_all_data" then horizon is inferred from the DataLoader
    ) -> None:

        self.horizon_train = horizon_train
        
        self.dataloader = dataloader

        num_SKUs = dataloader.num_units if num_SKUs is None else num_SKUs
        if not isinstance(num_SKUs, int):
            raise ValueError("num_SKUs must be an integer.")
        
        self.set_param("num_SKUs", num_SKUs, new=True)
        
        self.set_param("underage_cost", underage_cost, shape=(num_SKUs,), new=True)
        self.set_param("overage_cost", overage_cost, shape=(num_SKUs,), new=True)
        
        self.set_param("q_bound_low", q_bound_low, shape=(num_SKUs,), new=True)
        self.set_param("q_bound_high", q_bound_high, shape=(num_SKUs,), new=True)
        
        self.set_observation_space(dataloader.X_shape)
        self.set_action_space(dataloader.Y_shape)

        self.print=False
        
        super().__init__(mdp_info=MDPInfo(self.observation_space, self.action_space, gamma=gamma, horizon=horizon_train))

    def step(self, action):

        if self.print:
            print(action)
        
        cost_per_SKU = pinball_loss(self.demand, action, self.underage_cost, self.overage_cost)
        reward = -np.sum(cost_per_SKU) # negative because we want to minimize the cost

        terminated = False # in this problem there is no termination condition
        
        info = dict(
            demand=self.demand.copy(),
            action=action.copy(),
            cost_per_SKU=cost_per_SKU.copy()
        )

        truncated = self.set_index()

        if truncated:
            return None, reward, terminated, truncated, info
        else:
            observation, self.demand = self.get_observation()

            if self.print:
                print("##################")
                print("observation:", observation)
                print("next demand:", self.demand)
                time.sleep(5)

            return observation, reward, terminated, truncated, info

    def reset(self,
        start_index: Union[int,str] = None):

        if start_index is None:
            if self._mode == "train":
                if self.horizon_train == "use_all_data":
                    start_index = 0
                elif hasattr(self.dataloader, "is_distribution") and self.dataloader.is_distribution:
                    start_index = 0
                else:
                    start_index = "random"
            elif self._mode == "val":
                start_index = 0
            elif self._mode == "test":
                start_index = 0
            else:
                raise ValueError("Mode not recognized.")

        truncated = self.reset_index(start_index)

        observation, self.demand = self.get_observation()
        
        return observation, truncated
