# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/00_utils/21_torch_pre_processors.ipynb.

# %% auto 0
__all__ = ['FlattenTimeDim']

# %% ../../nbs/00_utils/21_torch_pre_processors.ipynb 3
import numpy as np
from typing import Optional

import torch


# %% ../../nbs/00_utils/21_torch_pre_processors.ipynb 4
class FlattenTimeDim():
    """
    Preprocessor to flatten the time and feature dimension of the input.
    Used, e.g., to convert time-series data for models that cannot process
    a time dimension such as MLPs or Regression models.
    """

    def __init__(self,
        allow_2d: Optional[bool] = False #
        ):
        self.allow_2d = allow_2d

    def check_input(self,
            input: torch.Tensor #
            ):
        """
        Check that the input is a PyTorch tensor with the correct shape.
        """
        # Check if the input is a PyTorch tensor
        if not isinstance(input, torch.Tensor):
            raise TypeError(f"Expected input to be a torch.Tensor but got {type(input)} instead.")

        # Check if the input tensor has the correct dimensions
        if input.dim() == 3:
            # If the input is 3D, it is valid regardless of allow_2d
            return
        elif input.dim() == 2:
            # If the input is 2D, check if 2D is allowed
            if not self.allow_2d:
                raise ValueError(
                    f"Expected input to have 3 dimensions with shape (batch_size, timesteps, features), "
                    f"but got 2D shape {input.shape} instead. 2D inputs are not allowed when allow_2d is False."
                )
        else:
            # If the input has dimensions other than 2 or 3
            expected_shape_msg = (
                "Expected input to have 3 dimensions with shape (batch_size, timesteps, features)"
                if not self.allow_2d
                else "Expected input to have 3 dimensions with shape (batch_size, timesteps, features) "
                     "or 2 dimensions with shape (batch_size, features)"
            )
            raise ValueError(f"{expected_shape_msg}, but got shape {input.shape} instead.")


    def __call__(self,
                input: torch.Tensor # 
                ) -> torch.Tensor:
        """
        Process the input tensor by keeping the batch dimension and flattening
        the time and feature dimensions.

        """

        # Validate the input tensor
        self.check_input(input)

        if input.dim()==2:
            output = input
        else:
            # Keep the batch dimension, flatten time and feature dimensions
            batch_size, timesteps, features = input.shape
            output = input.view(batch_size, -1)

        return output
