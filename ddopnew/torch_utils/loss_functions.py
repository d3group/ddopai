# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/10_torch_loss_functions.ipynb.

# %% auto 0
__all__ = ['TorchQuantileLoss', 'quantile_loss']

# %% ../../nbs/10_torch_loss_functions.ipynb 3
from typing import Union, Optional

import numpy as np
from ..utils import Parameter

import torch
import torch.nn as nn
import torch.nn.functional as F

# %% ../../nbs/10_torch_loss_functions.ipynb 5
class TorchQuantileLoss(nn.modules.loss._Loss):

    __constants__ = ['reduction']
    def __init__(self,reduction: str = 'mean') -> None:
        super().__init__(reduction=reduction)

    def forward(self, input, target, quantile):

        if isinstance(quantile, Parameter):
            quantile = quantile.get_value()
        
        quantile = torch.tensor(quantile, dtype=input.dtype, device=input.device)
            
        if not (target.shape[1] == input.shape[1] == quantile.shape[0]):
            warnings.warn(
                f"Mismatch in dimensions: target dimension 2 size ({target.size(2)}), input dimension 2 size ({input.size(2)}), "
                f"and quantile dimension 1 size ({quantile.size(1)}) must be the same. "
                "This will likely lead to incorrect results due to broadcasting. "
                "Please ensure they have the same size.",
                stacklevel=2,
            )

        return quantile_loss(input, target, quantile, reduction=self.reduction)

def quantile_loss(
    input: torch.Tensor,
    target: torch.Tensor,
    quantile: torch.Tensor,
    reduction: str = 'mean',
) -> torch.Tensor:

    if not (target.size() == input.size()):
        warnings.warn(
            f"Using a target size ({target.size()}) that is different to the input size ({input.size()}). "
            "This will likely lead to incorrect results due to broadcasting. "
            "Please ensure they have the same size.",
            stacklevel=2,
        )

    expanded_input, expanded_target = torch.broadcast_tensors(input, target)
    
    loss = torch.max((expanded_target - expanded_input) * quantile, (expanded_input - expanded_target) * (1 - quantile))

    if reduction == 'mean':
        return loss.mean()
    elif reduction == 'sum':
        return loss.sum()
    else:
        raise ValueError(f"reduction={reduction} is not valid")

    return loss
