# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/00_utils/20_torch_loss_functions.ipynb.

# %% auto 0
__all__ = ['quantile_loss', 'TorchQuantileLoss']

# %% ../../nbs/00_utils/20_torch_loss_functions.ipynb 3
from typing import Union, Optional

import numpy as np
from ..utils import Parameter

import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.nn.modules.loss import _Loss

# %% ../../nbs/00_utils/20_torch_loss_functions.ipynb 4
def quantile_loss(
    input: torch.Tensor,
    target: torch.Tensor,
    quantile: torch.Tensor,
    reduction: str = 'mean',
) -> torch.Tensor:

    if not (target.size() == input.size()):
        warnings.warn(
            f"Using a target size ({target.size()}) that is different to the input size ({input.size()}). "
            "This will likely lead to incorrect results due to broadcasting. "
            "Please ensure they have the same size.",
            stacklevel=2,
        )

    expanded_input, expanded_target = torch.broadcast_tensors(input, target)
    
    loss = torch.max((expanded_target - expanded_input) * quantile, (expanded_input - expanded_target) * (1 - quantile))

    if reduction == 'mean':
        return loss.mean()
    elif reduction == 'sum':
        return loss.sum()
    else:
        raise ValueError(f"reduction={reduction} is not valid")

    return loss

# %% ../../nbs/00_utils/20_torch_loss_functions.ipynb 5
class TorchQuantileLoss(_Loss):

    """
    Implmentation of the quantile loss in Pytorch.
    Unlike the Numpy-based implementation ```quantile_loss``` in the loss_functions module, this implementation
    this implementation reduces the results to a scalar value using the specified reduction method. This class is 
    used to train Pytorch models using the quantile loss.
    """

    __constants__ = ['reduction']
    def __init__(self,reduction: str = 'mean') -> None: #
        super().__init__(reduction=reduction)

    def forward(self, input: torch.Tensor, target: torch.Tensor, quantile: Parameter | np.ndarray) -> torch.Tensor: #

        """
        Forward pass of the quantile loss function.

        """

        if isinstance(quantile, Parameter):
            quantile = quantile.get_value()
        
        quantile = torch.tensor(quantile, dtype=input.dtype, device=input.device)
            
        if not (target.shape[1] == input.shape[1] == quantile.shape[0]):
            warnings.warn(
                f"Mismatch in dimensions: target dimension 2 size ({target.size(2)}), input dimension 2 size ({input.size(2)}), "
                f"and quantile dimension 1 size ({quantile.size(1)}) must be the same. "
                "This will likely lead to incorrect results due to broadcasting. "
                "Please ensure they have the same size.",
                stacklevel=2,
            )

        return quantile_loss(input, target, quantile, reduction=self.reduction)

