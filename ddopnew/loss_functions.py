# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_utils/00_loss_functions.ipynb.

# %% auto 0
__all__ = ['pinball_loss', 'quantile_loss', 'TorchQuantileLoss']

# %% ../nbs/00_utils/00_loss_functions.ipynb 3
from typing import Union, Optional

import numpy as np
from .utils import Parameter

import torch
import torch.nn as nn
import torch.nn.functional as F

# %% ../nbs/00_utils/00_loss_functions.ipynb 5
def pinball_loss(y_true, y_pred, underage_cost, overage_cost):

    if isinstance(underage_cost, Parameter):
        underage_cost = underage_cost.get_value()
    if isinstance(overage_cost, Parameter):
        overage_cost = overage_cost.get_value()
    
    loss = np.maximum(y_true - y_pred, 0) * underage_cost + np.maximum(y_pred - y_true, 0) * overage_cost

    return loss

# %% ../nbs/00_utils/00_loss_functions.ipynb 6
def quantile_loss(y_true, y_pred, quantile):

    if isinstance(quantile, Parameter):
        quantile = quantile.get_value()
    
    # assert shapes
    assert y_true.shape == y_pred.shape, "y_true and y_pred must have the same shape"
    
    loss = np.maximum((y_true - y_pred) * quantile, (y_pred - y_true) * (1 - quantile))

    return loss

# %% ../nbs/00_utils/00_loss_functions.ipynb 7
class TorchQuantileLoss(nn.modules.loss._Loss):

    __constants__ = ['reduction']
    def __init__(self,reduction: str = 'mean') -> None:
        super().__init__(reduction=reduction)

    def forward(self, input, target, quantile):

        if isinstance(quantile, Parameter):
            quantile = quantile.get_value()
        
        quantile = torch.tensor(quantile, dtype=input.dtype, device=input.device)
            
        if not (target.shape[1] == input.shape[1] == quantile.shape[0]):
            warnings.warn(
                f"Mismatch in dimensions: target dimension 2 size ({target.size(2)}), input dimension 2 size ({input.size(2)}), "
                f"and quantile dimension 1 size ({quantile.size(1)}) must be the same. "
                "This will likely lead to incorrect results due to broadcasting. "
                "Please ensure they have the same size.",
                stacklevel=2,
            )

        return quantile_loss(input, target, quantile, reduction=self.reduction)

def quantile_loss(
    input: torch.Tensor,
    target: torch.Tensor,
    quantile: torch.Tensor,
    reduction: str = 'mean',
) -> torch.Tensor:

    if not (target.size() == input.size()):
        warnings.warn(
            f"Using a target size ({target.size()}) that is different to the input size ({input.size()}). "
            "This will likely lead to incorrect results due to broadcasting. "
            "Please ensure they have the same size.",
            stacklevel=2,
        )

    expanded_input, expanded_target = torch.broadcast_tensors(input, target)
    
    loss = torch.max((expanded_target - expanded_input) * quantile, (expanded_input - expanded_target) * (1 - quantile))

    if reduction == 'mean':
        return loss.mean()
    elif reduction == 'sum':
        return loss.sum()
    else:
        raise ValueError(f"reduction={reduction} is not valid")

    return loss
