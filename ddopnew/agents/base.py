# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/40_base_agents/10_base_agents.ipynb.

# %% auto 0
__all__ = ['BaseAgent', 'BaseSAAagent']

# %% ../../nbs/40_base_agents/10_base_agents.ipynb 4
from abc import ABC, abstractmethod
from typing import Union
import numpy as np
from sklearn.utils.validation import check_array

from ..envs.base import BaseEnvironment

# # TEMPORARY
# from sklearn.utils.validation import check_array
# import numbers

# %% ../../nbs/40_base_agents/10_base_agents.ipynb 5
class BaseAgent():

    train_mode = "direct_fit" # or "epochs_fit" or "env_interaction"
    
    def __init__(self, environment_info):
        self.environment_info = environment_info
        self.mode = "train"

    @abstractmethod
    def draw_action(self, observation):
        pass

    def train(self):
        self.mode = "train"
        
    def eval(self):
        self.mode = "eval"

        

# %% ../../nbs/40_base_agents/10_base_agents.ipynb 6
class BaseSAAagent(BaseAgent):
    def __init__(self, environment_info):
        super().__init__(environment_info)

    def find_weighted_quantiles(self, weights, weightPosIndices, sl, y):
        
        """
        Find the weighted quantile of a range of data y. 
        It assumes that all arrays are of shape (n_samples, n_outputs).

        This function is designed for single-output only
        """

        # test shapes have lenght 2 with error
        assert len(y.shape) == 2, "y should be of shape (n_samples, n_outputs)"

        n_outputs = y.shape[1]

        yWeightPos = y[weightPosIndices]
        
        q = []

        if len(weights.shape) == 1:
            weights = weights.reshape(-1, 1)
        
        for i in range(n_outputs):
            
            indicesYSort = np.argsort(yWeightPos[:, i])

            ySorted = yWeightPos[indicesYSort, i]
            
            distributionFunction = np.cumsum(weights[indicesYSort, i])

            decisionIndex = np.where(distributionFunction >= sl)[0][0]
            
            q.append(ySorted[decisionIndex])
        
        return q
    
    def _validate_X_predict(self, X):
        """Validate X whenever one tries to predict"""

        X = check_array(X)

        n_features = X.shape[1]
        if self.n_features_ != n_features:
            raise ValueError("Number of features of the model must match the input. "
                             "Model n_features is %s and input n_features is %s "
                             % (self.n_features_, n_features))
        return X
